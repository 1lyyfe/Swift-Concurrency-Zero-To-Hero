# 2.1 – `Task`

Swift’s `Task` creates a new **concurrent unit of work**. It’s the primitive you use when you want to start async work *now*, control its **lifecycle** (cancel, hold a reference), choose **actor context** (UI vs non-UI), and influence **priority**.

> TL;DR: Use `Task` when you need an owned, cancellable, configurable async context.
> Use `async let` for a small, fixed number of sibling operations in one scope.
> Use `TaskGroup` for a dynamic fan-out of child tasks.

---

## What `Task` gives you

- **Ownership & lifecycle**
  - You hold a `Task` reference (e.g., `var current: Task<Void, Never>?`) and can `cancel()` it.
  - Great for **“last request wins”** and **view lifecycle** cleanup.

- **Actor context**
  - `Task { … }`: runs on a non-isolated context by default (not guaranteed main).
  - `Task { @MainActor in … }`: runs on the **main actor** (UI-safe throughout).
  - You can also hop with `await MainActor.run { … }` for specific updates.

- **Priority (scheduling hint)**
  - `Task(priority: .userInitiated)` etc.
  - Read within the task via `Task.currentPriority`.

- **Structured concurrency inheritance**
  - If you create a `Task` **inside** a task, it inherits **priority** and **cancellation** by default.
  - Cancelling the parent will cancel children.

---

## Key patterns 

#### 1) Fire-and-manage (UI button)

```
var current: Task<Void, Never>?

current = Task {
  defer { current = nil }
  try await doWork()
}
```
- Keep a handle for cancel on tap or cancel on disappear**.

#### 2) Main actor end-to-end.
```
Task { @MainActor in
  // Entire body is UI-actor isolated
  model.value = "Updated safely"
}
```
- Prefer this when your task will mostly touch UI.

### 3) Off-main thread + hop onto main at update points
```
Task {
  let data = try await load()
  await MainActor.run { viewState = data }
}
```
- Prefer this when the heavy work is off-main but small UI patches are needed.

### 4) Explicit background priority
```
Task(priority: .background) {
  // throttle this work relative to user-initiated tasks
}
```
---

## Use Cases

| Use case                                                                                | Choose          |
| --------------------------------------------------------------------------------------- | --------------- |
| Start a **single** piece of work, hold a handle, cancel it, configure priority or actor | **`Task`**      |
| Start a **small, fixed** number of independent operations in one scope                  | **`async let`** |
| Start a **dynamic** number of operations (list/loop), collect/merge results             | **`TaskGroup`** |

---

## Actor context explained

- **Default** `Task { … }`: Not isolated to the main actor. You must hop to main for UI updates (`await MainActor.run { … }`) or run the whole body on main (`Task { @MainActor in … }`).

- **Why it matters**: UI must be mutated on the main actor; off-main mutations can crash or cause data races.
---

## Cancellation (cooperative)
- `Task.cancel()` **requests cancellation**; the running code must check (e.g., `Task.checkCancellation()` or at suspension points) to stop promptly.
- Modern async APIs (like `URLSession`) and our` NetworkClient` check near suspension, so cancels feel immediate.
- Treat CancellationError as a `non-failure` outcome in your UI copy.
 
---
## Priority (what it is and isn’t)

- It’s a **hint**, not a guarantee. The scheduler uses it to order work.
- Use `.userInitiated` for interactive work; `.background` for maintenance.
- You can inspect within a task via `Task.currentPriority`, e.g. for logging/teaching.
---

## Common pitfalls
- **Updating UI off-main** → use `Task { @MainActor in … }` or a`wait MainActor.run { … }`.
- **Forgetting to cancel** on view disappear → stale updates or wasted battery.
- **Confusing** `Task` with `async let` → `Task` owns lifecycle; `async let` is scoped, compiler-enforced to await before leaving scope.

---

## Knowledge Check With Examples

##### **Q: How does Task interact with structured concurrency?**
- If created inside a task, it inherits cancellation/priority.
- If you `cancel()` the parent, children receive cancellation.
- Detached tasks (2.3) do not inherit; use sparingly.

##### **Q: When do you use `Task { @MainActor in … }` vs `MainActor.run?`**

- If the whole body is UI work → `Task { @MainActor in … }`.
- If only UI updates are on main → off-main task + `MainActor.run` for patches.

**Think of it like this:** 
- **Task on the main actor** = “I’m doing mostly UI work (or main-actor–confined stuff) end-to-end.”
- **Off-main task + patch UI** = “I’m doing real work off the UI actor (network/IO/CPU), and I’ll hop to main only to update the screen.”

##### **Decision checklist (use this in your head during reviews)**

- **Is most of the code touching UI / main-confined APIs?**
→ `Task { @MainActor in … }`

- **Is most of the code network/IO/CPU and only the end patches the UI?**
→ `Task { … } + await MainActor.run { … }`

- **Am I mutating UIKit, AppKit, or a main-queue Core Data context?**
→ Main actor.

- **Am I doing image processing, JSON decoding, compression, regex, hashing?**
→ Off main; patch UI later.

- **Do I need precise animation sequencing or navigation orchestration?**
→ Main actor.

- **Will this block the UI if it accidentally runs on main?**
→ Keep off main; be explicit. 

**Code Examples:**

##### **When to run the entire body on the main actor**:
1) **UI-first flows (navigation, alerts, state orchestration)**
    - You’re coordinating UI state, pushing routes, showing sheets, and only touching lightweight async calls.**
    
    ```
    Task { @MainActor in
        // 1) Change view state, drive navigation
        router.push(.profile)
    
        // 2) Light async call (already optimized off-main internally)
        // e.g., URLSession’s async APIs suspend without blocking the main actor.
        let user = try await api.fetchCurrentUser()
    
        // 3) Update UI state directly (we're on the main actor the whole time)
        viewState.user = user
        viewState.banner = .success("Welcome back, \(user.firstName)")
    }
    ```

    **Why main-actor here?**
    - Most of the work is UI state orchestration.
    - Any brief suspensions (e.g. networking) don’t block the main thread—they suspend—and you resume still on the main actor to continue UI updates.
    - You avoid dozens of `MainActor.run` hops and keep the flow crystal clear


2) **SwiftUI animation/transition orchestration** 
    - You’re sequencing animations; keep it on the UI actor so state changes and animations stay coherent.

    ```
    Task { @MainActor in
    withAnimation { panel.isExpanded = true }
    try? await Task.sleep(for: .milliseconds(250))
    withAnimation(.spring()) { panel.showDetails = true }
    }
    ```
      **Why main-actor here?**
    - Animation and view mutations must be main-actor bound; this keeps timing/pacing precise.


##### **When to offload work and only patch UI at safe points**

 - **Network + heavy JSON decoding + image processing**

    - Do the costly parts off main; hop back only to present results.

    ```
    Task {
    // 1) Network & decode (off main)
    let (data, _) = try await URLSession.shared.data(from: endpoint)
    let user = try JSONDecoder().decode(User.self, from: data)

    // 2) CPU-bound processing (thumbnail)
    let thumb = await ImagePipeline.shared.resize(imageData: user.avatarData, to: .square(120))

    // 3) Patch UI on main
    await MainActor.run {
        viewState.user = user
        viewState.avatar = thumb
        viewState.isLoading = false
        }
    }
    ```
    **Why off-main here?**
      -   Decoding and image ops are CPU-heavy.
    - Keep the UI actor free; only cross to main when you actually mutate UI.




##### **Q: What does “cooperative cancellation” mean?**
- The runtime sets a cancellation flag. Your code must **check** or hit a suspension point for the cancel to take effect.






