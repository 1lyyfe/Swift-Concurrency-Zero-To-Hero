# 1.3 – `async let`

Swift’s `async let` lets you start multiple **child tasks in the same scope** so they can run **in parallel**, then `await` their results later. It’s part of **structured concurrency**: the compiler enforces that those child tasks must be awaited (or cancelled) before you leave the scope.

---

## Why use `async let`?
- **Performance** — kick off two+ **independent** async calls immediately and overlap the waits.
- **Clarity** — declare the work up front; read results where you need them.
- **Safety** — if one child throws, the others are **automatically cancelled**.

> **Rule of thumb:** Use `async let` for a **small, fixed number** of independent operations.  
> If the number of tasks is dynamic (e.g. a variable-length array of URLs), prefer a **`TaskGroup`**.

---

## Mental model (short & sharp)

- `await` **suspends**; the function resumes later at that line.
- `async let` **starts work now** without waiting.
- You **must** eventually `await` each `async let` binding before scope exit (or discard it with `await _ = …`).
- If an `await` throws, **siblings are cancelled**.
- Results are returned in **binding order**, not completion order.

---

## Sequential vs Parallel

### Sequential (`await` then `await`)
```swift
let a = try await fetchA()  // waits until A finishes
let b = try await fetchB()  // then starts B
// total time ≈ time(A) + time(B)
```
- Work does not overlap.
- Simpler timing, but slower if both calls spend time waiting (network, disk).

### Parallel (async let then await)

```swift
async let a = fetchA()      // start A now
async let b = fetchB()      // start B now
let (ra, rb) = try await (a, b)  // wait for both
// total time ≈ max(time(A), time(B))
```
- Work overlaps immediately.
- The tuple (ra, rb) follows the binding order (a, b), not which one finished first. 

---

## Ordering, errors, and cancellation

- **Ordering:** Even if `b` finishes first, `let (ra, rb) = try await (a, b)` still places A’s result in `ra` and B’s in `rb`.

- **Error propagation:** If `await a` throws, Swift cancels `b` automatically (cooperative cancellation). Your code sees the thrown error; you typically do not need to manually cancel siblings.
- **Scope exit**: Returning early (or throwing) before awaiting bindings cancels any in-flight `async let`.



---

## When to avoid async let
- The number of subtasks is dynamic or large → use `TaskGroup`.
- The work is long-lived and should outlive the scope → consider `Task { … }` or a dedicated component to own that lifecycle.
- The tasks depend on one another (A needs B’s output) → **keep it sequential**.

---
## Hands-on (what you’ll see in the demo)
With both requests set to **1.0s**:
- Sequential: elapsed ≈ **2.00s**
- Parallel: elapsed ≈ **1.00s**

If you set A = 0.10s, B = **0.40s:**
- Parallel time tracks the slower branch → elapsed ≈ 0.40s

**Open the Xcode console: our NetworkClient prints start → delay → completion so you can see the overlap**.

---

## “Staff-level” notes (deeper details)
- **Structured concurrency** ties child tasks to the current task. The compiler requires you to `await` or discard every `async let` before leaving the scope; this prevents orphaned tasks.

- **Cancellation is cooperative**; libraries like `URLSession` (modern async APIs) and our `NetworkClient` check for cancellation near suspension points. If your code does heavy CPU work, insert `Task.checkCancellation()` in strategic locations.
- **No guaranteed parallel CPU**: `async let` overlaps waiting and work; true CPU parallelism depends on the system’s scheduler and available cores. You still win big for I/O-bound tasks.

- **Error hygiene**: treat `CancellationError` distinctly. It’s not a failure; it’s a chosen outcome.

---
## Common pitfalls
- **Forgetting to await** an `async let` before scope exit → compile error (good!).

- **Using `async let` for dependent tasks** → you just added latency. Keep it sequential when there’s a dependency.

- **Holding `async let` across unrelated work** → keep scopes tight; await promptly.
---

##  Patterns you can practice next
1. **Timeout wrapper**
Cancel both child tasks if total wall time exceeds a budget. Show timeout vs user cancel vs error in the UI.

3. **Selective retry**
Retry on server errors (with jitter), but do not retry on cancellation.

3. **Third branch**
Add a third async let and show that parallel time still tracks the max(duration).

---

## Knowledge Check

After working through this part of the tutorial you should be able to:

1. Explain the difference between `concurrency` and `parallelism` in Swift, and how `async let` relates to structured concurrency.

2. Walk through what happens if `await a` throws while `b` is still running.

2. Discuss when you would choose `TaskGroup` over async let.
---

## Full minimal example (copy/paste as you desire)
```
func fetchA() async throws -> String { 
    try await Task.sleep(for: .seconds(1)); return "A" 
}

func fetchB() async throws -> String { 
    try await Task.sleep(for: .seconds(1)); return "B" 
}

// Sequential
func twoSequential() async throws -> (String, String) {
    let a = try await fetchA()
    let b = try await fetchB()
    return (a, b)
}

// Parallel
func twoParallel() async throws -> (String, String) {
    async let a = fetchA()
    async let b = fetchB()
    return try await (a, b)
}
```

---

## Checklist
 - Tasks are independent (no data dependency).
- Number of tasks is small and fixed.
- You await all async let bindings in the same scope.
- Cancellation and errors are handled; cancellation is not treated as a failure.
